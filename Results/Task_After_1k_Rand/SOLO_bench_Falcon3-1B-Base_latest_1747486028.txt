1. Words must follow the exact order (not wordplay/ anagrams) from the above list
2. Punctuation and case will not count as valid words though it will add to sentence length
3. Use of any other parts of speech which may be defined by word lists is forbidden without being acknowledged in a footnote.
4. (In case it does not divide by using t' for an extra normalization). For each s in Z such that |s|<q*(T-1)/q we construct a polynomial S defined like so:
5. If S and its degree are both less than q-2 then simply use T to divide P into one or two more factors and check if it satisfies (T^q-1)/(q*(T+1). This can be done in constant time provided we have the correct table values for the coefficients of the different forms mentioned above so that T^n|(p/(2*4*573+q)), where n=0 is zero. Therefore, we use an extra table to store these results as well as a table for q if it falls within -11 and k+1 to m+1 even modulo 574. This is used to check that any coefficient of the resulting factor falls within the interval mentioned above before extracting the other factor
6. If either case is false then first test whether 2*4*573+q divides s_s0 in such a way that we get one additional factor and extract the result as it will be in Q[r|(b/m) where b/m belongs to the last interval mentioned above. However, if q is between these intervals then we do not know whether P/(2*4*573+q) divides s_s0; thus, we use a separate table with coefficients that help in deciding this too. This will be used either to normalise f(t), which by its nature cannot have integer coefficients and to extract the coefficient of the other factor if it exists. Note that all calculations carried out are done modulo q and this has a constant time cost so the overall algorithm runs in O((m/(4*573))) steps but it also takes (p*(m+1)/q)*2^n/T*(log k)/(log q)+1 where log is base 10, p is prime number and we have n=0 for first step, and we only add one constant if q lies within the intervals mentioned previously.
